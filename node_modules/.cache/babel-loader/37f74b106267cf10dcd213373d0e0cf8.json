{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\";\nimport { useAuth } from \"../../context/AuthContext\";\nimport useFetch from \"../../hooks/useFetch\"; // import useScreenWidth from \"../../hooks/useScreenWidth\";\n\nimport { useCallback } from \"react\";\nimport { socket } from \"../../utilities/socker\";\n/**\n * sendMessage():send a message to a chat based on ChatId and Sender Id\n * getMessages(): fetch all messages for chatId\n * {chatId}\n * messages input...\n */\n\nconst useSingleChat = (chatId, takerId) => {\n  _s();\n\n  const {\n    auth\n  } = useAuth();\n  const {\n    sendRequest\n  } = useFetch();\n  const [messages, setMessages] = useState([]);\n  const [messageContent, setMessageContent] = useState(\"\");\n  const [isSent, setIsSent] = useState(false);\n  const [socketConnected, setSocketConnected] = useState(false);\n  const userId = auth.userId; // socket IO\n\n  useEffect(() => {\n    if (!socketConnected) {\n      socket.once(\"connection\", () => {\n        setSocketConnected(true);\n      });\n      socket.emit(\"setup\", userId);\n      socket.emit(\"join chat\", chatId);\n    } else {\n      return;\n    }\n  }, []);\n  useEffect(() => {\n    socket.on(\"receive message\", _ref => {\n      let {\n        chatId,\n        sender,\n        content\n      } = _ref;\n\n      if (content) {\n        let newMessage = {\n          _id: null,\n          chatId: chatId,\n          sender: sender,\n          content: content,\n          createdAt: null,\n          updatedAt: null\n        };\n        setMessages(prev => [...prev, newMessage]);\n      }\n    });\n    return () => socket.off(\"receive message\");\n  }, [messages]); // send message\n\n  const sendMessage = useCallback(async content => {\n    let responseData;\n\n    try {\n      // io send message\n      socket.off(\"send message\");\n      responseData = await sendRequest(process.env.REACT_APP_BASE_URL + \"messages/\", \"POST\", JSON.stringify({\n        chatId,\n        sender: auth.userId,\n        content: content\n      }));\n      socket.emit(\"send message\", {\n        chatId,\n        userId,\n        takerId,\n        content\n      });\n      setMessageContent(\"\");\n      setIsSent(!isSent);\n    } catch (e) {\n      console.log(e);\n    }\n  }, [sendRequest, isSent]); // get messages for a chat\n\n  useEffect(() => {\n    const getMessages = async () => {\n      let responseData;\n\n      try {\n        responseData = await sendRequest(process.env.REACT_APP_BASE_URL + \"messages/\" + chatId, \"GET\");\n\n        if (responseData) {\n          setMessages(responseData); // socket join room\n        }\n      } catch (e) {\n        console.log(e);\n      }\n    };\n\n    getMessages();\n  }, [chatId, sendMessage]); //handle enter message\n\n  const enterMessage = e => setMessageContent(prev => e.target.value);\n\n  return {\n    chatId,\n    messages,\n    messageContent,\n    enterMessage,\n    sendMessage\n  };\n};\n\n_s(useSingleChat, \"xdPA16JSuLPbdbK6l9AL03Qvp7c=\", false, function () {\n  return [useAuth, useFetch];\n});\n\nexport default useSingleChat;","map":{"version":3,"sources":["/Users/bingnanli/Desktop/code/chat-app/client/src/pages/SingleChat/useSingleChat.js"],"names":["useEffect","useState","useAuth","useFetch","useCallback","socket","useSingleChat","chatId","takerId","auth","sendRequest","messages","setMessages","messageContent","setMessageContent","isSent","setIsSent","socketConnected","setSocketConnected","userId","once","emit","on","sender","content","newMessage","_id","createdAt","updatedAt","prev","off","sendMessage","responseData","process","env","REACT_APP_BASE_URL","JSON","stringify","e","console","log","getMessages","enterMessage","target","value"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AACA,SAASC,OAAT,QAAwB,2BAAxB;AACA,OAAOC,QAAP,MAAqB,sBAArB,C,CACA;;AACA,SAASC,WAAT,QAA4B,OAA5B;AACA,SAASC,MAAT,QAAuB,wBAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,aAAa,GAAG,CAACC,MAAD,EAASC,OAAT,KAAqB;AAAA;;AACzC,QAAM;AAAEC,IAAAA;AAAF,MAAWP,OAAO,EAAxB;AACA,QAAM;AAAEQ,IAAAA;AAAF,MAAkBP,QAAQ,EAAhC;AAEA,QAAM,CAACQ,QAAD,EAAWC,WAAX,IAA0BX,QAAQ,CAAC,EAAD,CAAxC;AACA,QAAM,CAACY,cAAD,EAAiBC,iBAAjB,IAAsCb,QAAQ,CAAC,EAAD,CAApD;AACA,QAAM,CAACc,MAAD,EAASC,SAAT,IAAsBf,QAAQ,CAAC,KAAD,CAApC;AACA,QAAM,CAACgB,eAAD,EAAkBC,kBAAlB,IAAwCjB,QAAQ,CAAC,KAAD,CAAtD;AAEA,QAAMkB,MAAM,GAAGV,IAAI,CAACU,MAApB,CATyC,CAWzC;;AACAnB,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAACiB,eAAL,EAAsB;AACpBZ,MAAAA,MAAM,CAACe,IAAP,CAAY,YAAZ,EAA0B,MAAM;AAC9BF,QAAAA,kBAAkB,CAAC,IAAD,CAAlB;AACD,OAFD;AAIAb,MAAAA,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqBF,MAArB;AACAd,MAAAA,MAAM,CAACgB,IAAP,CAAY,WAAZ,EAAyBd,MAAzB;AACD,KAPD,MAOO;AACL;AACD;AACF,GAXQ,EAWN,EAXM,CAAT;AAaAP,EAAAA,SAAS,CAAC,MAAM;AACdK,IAAAA,MAAM,CAACiB,EAAP,CAAU,iBAAV,EAA6B,QAAiC;AAAA,UAAhC;AAAEf,QAAAA,MAAF;AAAUgB,QAAAA,MAAV;AAAkBC,QAAAA;AAAlB,OAAgC;;AAC5D,UAAIA,OAAJ,EAAa;AACX,YAAIC,UAAU,GAAG;AACfC,UAAAA,GAAG,EAAE,IADU;AAEfnB,UAAAA,MAAM,EAAEA,MAFO;AAGfgB,UAAAA,MAAM,EAAEA,MAHO;AAIfC,UAAAA,OAAO,EAAEA,OAJM;AAKfG,UAAAA,SAAS,EAAE,IALI;AAMfC,UAAAA,SAAS,EAAE;AANI,SAAjB;AASAhB,QAAAA,WAAW,CAAEiB,IAAD,IAAU,CAAC,GAAGA,IAAJ,EAAUJ,UAAV,CAAX,CAAX;AACD;AACF,KAbD;AAcA,WAAO,MAAMpB,MAAM,CAACyB,GAAP,CAAW,iBAAX,CAAb;AACD,GAhBQ,EAgBN,CAACnB,QAAD,CAhBM,CAAT,CAzByC,CA2CzC;;AACA,QAAMoB,WAAW,GAAG3B,WAAW,CAC7B,MAAOoB,OAAP,IAAmB;AACjB,QAAIQ,YAAJ;;AACA,QAAI;AACF;AACA3B,MAAAA,MAAM,CAACyB,GAAP,CAAW,cAAX;AACAE,MAAAA,YAAY,GAAG,MAAMtB,WAAW,CAC9BuB,OAAO,CAACC,GAAR,CAAYC,kBAAZ,GAAiC,WADH,EAE9B,MAF8B,EAG9BC,IAAI,CAACC,SAAL,CAAe;AACb9B,QAAAA,MADa;AAEbgB,QAAAA,MAAM,EAAEd,IAAI,CAACU,MAFA;AAGbK,QAAAA,OAAO,EAAEA;AAHI,OAAf,CAH8B,CAAhC;AASAnB,MAAAA,MAAM,CAACgB,IAAP,CAAY,cAAZ,EAA4B;AAAEd,QAAAA,MAAF;AAAUY,QAAAA,MAAV;AAAkBX,QAAAA,OAAlB;AAA2BgB,QAAAA;AAA3B,OAA5B;AACAV,MAAAA,iBAAiB,CAAC,EAAD,CAAjB;AACAE,MAAAA,SAAS,CAAC,CAACD,MAAF,CAAT;AACD,KAfD,CAeE,OAAOuB,CAAP,EAAU;AACVC,MAAAA,OAAO,CAACC,GAAR,CAAYF,CAAZ;AACD;AACF,GArB4B,EAsB7B,CAAC5B,WAAD,EAAcK,MAAd,CAtB6B,CAA/B,CA5CyC,CAqEzC;;AACAf,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMyC,WAAW,GAAG,YAAY;AAC9B,UAAIT,YAAJ;;AAEA,UAAI;AACFA,QAAAA,YAAY,GAAG,MAAMtB,WAAW,CAC9BuB,OAAO,CAACC,GAAR,CAAYC,kBAAZ,GAAiC,WAAjC,GAA+C5B,MADjB,EAE9B,KAF8B,CAAhC;;AAKA,YAAIyB,YAAJ,EAAkB;AAChBpB,UAAAA,WAAW,CAACoB,YAAD,CAAX,CADgB,CAEhB;AACD;AACF,OAVD,CAUE,OAAOM,CAAP,EAAU;AACVC,QAAAA,OAAO,CAACC,GAAR,CAAYF,CAAZ;AACD;AACF,KAhBD;;AAiBAG,IAAAA,WAAW;AACZ,GAnBQ,EAmBN,CAAClC,MAAD,EAASwB,WAAT,CAnBM,CAAT,CAtEyC,CA2FzC;;AACA,QAAMW,YAAY,GAAIJ,CAAD,IAAOxB,iBAAiB,CAAEe,IAAD,IAAUS,CAAC,CAACK,MAAF,CAASC,KAApB,CAA7C;;AAEA,SAAO;AACLrC,IAAAA,MADK;AAELI,IAAAA,QAFK;AAGLE,IAAAA,cAHK;AAIL6B,IAAAA,YAJK;AAKLX,IAAAA;AALK,GAAP;AAOD,CArGD;;GAAMzB,a;UACaJ,O,EACOC,Q;;;AAqG1B,eAAeG,aAAf","sourcesContent":["import { useEffect, useState } from \"react\";\nimport { useAuth } from \"../../context/AuthContext\";\nimport useFetch from \"../../hooks/useFetch\";\n// import useScreenWidth from \"../../hooks/useScreenWidth\";\nimport { useCallback } from \"react\";\nimport { socket } from \"../../utilities/socker\";\n\n/**\n * sendMessage():send a message to a chat based on ChatId and Sender Id\n * getMessages(): fetch all messages for chatId\n * {chatId}\n * messages input...\n */\nconst useSingleChat = (chatId, takerId) => {\n  const { auth } = useAuth();\n  const { sendRequest } = useFetch();\n\n  const [messages, setMessages] = useState([]);\n  const [messageContent, setMessageContent] = useState(\"\");\n  const [isSent, setIsSent] = useState(false);\n  const [socketConnected, setSocketConnected] = useState(false);\n\n  const userId = auth.userId;\n\n  // socket IO\n  useEffect(() => {\n    if (!socketConnected) {\n      socket.once(\"connection\", () => {\n        setSocketConnected(true);\n      });\n\n      socket.emit(\"setup\", userId);\n      socket.emit(\"join chat\", chatId);\n    } else {\n      return;\n    }\n  }, []);\n\n  useEffect(() => {\n    socket.on(\"receive message\", ({ chatId, sender, content }) => {\n      if (content) {\n        let newMessage = {\n          _id: null,\n          chatId: chatId,\n          sender: sender,\n          content: content,\n          createdAt: null,\n          updatedAt: null,\n        };\n\n        setMessages((prev) => [...prev, newMessage]);\n      }\n    });\n    return () => socket.off(\"receive message\");\n  }, [messages]);\n\n  // send message\n  const sendMessage = useCallback(\n    async (content) => {\n      let responseData;\n      try {\n        // io send message\n        socket.off(\"send message\");\n        responseData = await sendRequest(\n          process.env.REACT_APP_BASE_URL + \"messages/\",\n          \"POST\",\n          JSON.stringify({\n            chatId,\n            sender: auth.userId,\n            content: content,\n          })\n        );\n        socket.emit(\"send message\", { chatId, userId, takerId, content });\n        setMessageContent(\"\");\n        setIsSent(!isSent);\n      } catch (e) {\n        console.log(e);\n      }\n    },\n    [sendRequest, isSent]\n  );\n\n  // get messages for a chat\n  useEffect(() => {\n    const getMessages = async () => {\n      let responseData;\n\n      try {\n        responseData = await sendRequest(\n          process.env.REACT_APP_BASE_URL + \"messages/\" + chatId,\n          \"GET\"\n        );\n\n        if (responseData) {\n          setMessages(responseData);\n          // socket join room\n        }\n      } catch (e) {\n        console.log(e);\n      }\n    };\n    getMessages();\n  }, [chatId, sendMessage]);\n\n  //handle enter message\n  const enterMessage = (e) => setMessageContent((prev) => e.target.value);\n\n  return {\n    chatId,\n    messages,\n    messageContent,\n    enterMessage,\n    sendMessage,\n  };\n};\n\nexport default useSingleChat;\n"]},"metadata":{},"sourceType":"module"}